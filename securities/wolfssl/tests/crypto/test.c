/* test.c
 *
 */

#include <libTest.h>


#if defined(USE_CERT_BUFFERS_1024) || defined(USE_CERT_BUFFERS_2048) || !defined(NO_DH)
#include "certsTest.h"
#endif


#ifdef THREADX
    /* since just testing, use THREADX log printf instead */
    int dc_log_printf(char*, ...);
        #undef printf
        #define printf dc_log_printf
#endif

#include "wolfcrypt/test/test.h"


#ifdef HAVE_FIPS
static void myFipsCb(int ok, int err, const char* hash)
{
    printf("in my Fips callback, ok = %d, err = %d\n", ok, err);
    printf("message = %s\n", wc_GetErrorString(err));
    printf("hash = %s\n", hash);

    if (err == IN_CORE_FIPS_E) {
        printf("In core integrity hash check failure, copy above hash\n");
        printf("into verifyCore[] in fips_test.c and rebuild\n");
    }
}
#endif /* HAVE_FIPS */






#ifdef HAVE_NTRU
byte GetEntropy(ENTROPY_CMD cmd, byte* out)
{
    static RNG rng;

    if (cmd == INIT)
        return (wc_InitRng(&rng) == 0) ? 1 : 0;

    if (out == NULL)
        return 0;

    if (cmd == GET_BYTE_OF_ENTROPY)
        return (wc_RNG_GenerateBlock(&rng, out, 1) == 0) ? 1 : 0;

    if (cmd == GET_NUM_BYTES_PER_BYTE_OF_ENTROPY) {
        *out = 1;
        return 1;
    }

    return 0;
}

#endif /* HAVE_NTRU */


#ifdef OPENSSL_EXTRA

int openssl_test(void)
{
    EVP_MD_CTX md_ctx;
    testVector a, b, c, d, e, f;
    byte       hash[SHA256_DIGEST_SIZE*2];  /* max size */

    (void)a;
    (void)b;
    (void)c;
    (void)e;
    (void)f;

#ifndef NO_MD5

    a.input  = "1234567890123456789012345678901234567890123456789012345678"
               "9012345678901234567890";
    a.output = "\x57\xed\xf4\xa2\x2b\xe3\xc9\x55\xac\x49\xda\x2e\x21\x07\xb6"
               "\x7a";
    a.inLen  = strlen(a.input);
    a.outLen = MD5_DIGEST_SIZE;

    EVP_MD_CTX_init(&md_ctx);
    EVP_DigestInit(&md_ctx, EVP_md5());

    EVP_DigestUpdate(&md_ctx, a.input, (unsigned long)a.inLen);
    EVP_DigestFinal(&md_ctx, hash, 0);

    if (memcmp(hash, a.output, MD5_DIGEST_SIZE) != 0)
        return -71;

#endif /* NO_MD5 */

#ifndef NO_SHA

    b.input  = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
               "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
               "aaaaaaaaaa";
    b.output = "\xAD\x5B\x3F\xDB\xCB\x52\x67\x78\xC2\x83\x9D\x2F\x15\x1E\xA7"
               "\x53\x99\x5E\x26\xA0";
    b.inLen  = strlen(b.input);
    b.outLen = SHA_DIGEST_SIZE;

    EVP_MD_CTX_init(&md_ctx);
    EVP_DigestInit(&md_ctx, EVP_sha1());

    EVP_DigestUpdate(&md_ctx, b.input, (unsigned long)b.inLen);
    EVP_DigestFinal(&md_ctx, hash, 0);

    if (memcmp(hash, b.output, SHA_DIGEST_SIZE) != 0)
        return -72;

#endif /* NO_SHA */


    d.input  = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
    d.output = "\x24\x8D\x6A\x61\xD2\x06\x38\xB8\xE5\xC0\x26\x93\x0C\x3E\x60"
               "\x39\xA3\x3C\xE4\x59\x64\xFF\x21\x67\xF6\xEC\xED\xD4\x19\xDB"
               "\x06\xC1";
    d.inLen  = strlen(d.input);
    d.outLen = SHA256_DIGEST_SIZE;

    EVP_MD_CTX_init(&md_ctx);
    EVP_DigestInit(&md_ctx, EVP_sha256());

    EVP_DigestUpdate(&md_ctx, d.input, (unsigned long)d.inLen);
    EVP_DigestFinal(&md_ctx, hash, 0);

    if (memcmp(hash, d.output, SHA256_DIGEST_SIZE) != 0)
        return -78;

#ifdef WOLFSSL_SHA384

    e.input  = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhi"
               "jklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu";
    e.output = "\x09\x33\x0c\x33\xf7\x11\x47\xe8\x3d\x19\x2f\xc7\x82\xcd\x1b"
               "\x47\x53\x11\x1b\x17\x3b\x3b\x05\xd2\x2f\xa0\x80\x86\xe3\xb0"
               "\xf7\x12\xfc\xc7\xc7\x1a\x55\x7e\x2d\xb9\x66\xc3\xe9\xfa\x91"
               "\x74\x60\x39";
    e.inLen  = strlen(e.input);
    e.outLen = SHA384_DIGEST_SIZE;

    EVP_MD_CTX_init(&md_ctx);
    EVP_DigestInit(&md_ctx, EVP_sha384());

    EVP_DigestUpdate(&md_ctx, e.input, (unsigned long)e.inLen);
    EVP_DigestFinal(&md_ctx, hash, 0);

    if (memcmp(hash, e.output, SHA384_DIGEST_SIZE) != 0)
        return -79;

#endif /* WOLFSSL_SHA384 */


#ifdef WOLFSSL_SHA512

    f.input  = "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhi"
               "jklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu";
    f.output = "\x8e\x95\x9b\x75\xda\xe3\x13\xda\x8c\xf4\xf7\x28\x14\xfc\x14"
               "\x3f\x8f\x77\x79\xc6\xeb\x9f\x7f\xa1\x72\x99\xae\xad\xb6\x88"
               "\x90\x18\x50\x1d\x28\x9e\x49\x00\xf7\xe4\x33\x1b\x99\xde\xc4"
               "\xb5\x43\x3a\xc7\xd3\x29\xee\xb6\xdd\x26\x54\x5e\x96\xe5\x5b"
               "\x87\x4b\xe9\x09";
    f.inLen  = strlen(f.input);
    f.outLen = SHA512_DIGEST_SIZE;

    EVP_MD_CTX_init(&md_ctx);
    EVP_DigestInit(&md_ctx, EVP_sha512());

    EVP_DigestUpdate(&md_ctx, f.input, (unsigned long)f.inLen);
    EVP_DigestFinal(&md_ctx, hash, 0);

    if (memcmp(hash, f.output, SHA512_DIGEST_SIZE) != 0)
        return -80;

#endif /* WOLFSSL_SHA512 */


#ifndef NO_MD5
    if (RAND_bytes(hash, sizeof(hash)) != 1)
        return -73;

    c.input  = "what do ya want for nothing?";
    c.output = "\x55\x78\xe8\x48\x4b\xcc\x93\x80\x93\xec\x53\xaf\x22\xd6\x14"
               "\x76";
    c.inLen  = strlen(c.input);
    c.outLen = MD5_DIGEST_SIZE;

    HMAC(EVP_md5(),
                 "JefeJefeJefeJefe", 16, (byte*)c.input, (int)c.inLen, hash, 0);

    if (memcmp(hash, c.output, MD5_DIGEST_SIZE) != 0)
        return -74;

#endif /* NO_MD5 */

#ifndef NO_DES3
    { /* des test */
    const byte vector[] = { /* "now is the time for all " w/o trailing 0 */
        0x6e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,
        0x68,0x65,0x20,0x74,0x69,0x6d,0x65,0x20,
        0x66,0x6f,0x72,0x20,0x61,0x6c,0x6c,0x20
    };

    byte plain[24];
    byte cipher[24];

    const_DES_cblock key =
    {
        0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef
    };

    DES_cblock iv =
    {
        0x12,0x34,0x56,0x78,0x90,0xab,0xcd,0xef
    };

    DES_key_schedule sched;

    const byte verify[] =
    {
        0x8b,0x7c,0x52,0xb0,0x01,0x2b,0x6c,0xb8,
        0x4f,0x0f,0xeb,0xf3,0xfb,0x5f,0x86,0x73,
        0x15,0x85,0xb3,0x22,0x4b,0x86,0x2b,0x4b
    };

    DES_key_sched(&key, &sched);

    DES_cbc_encrypt(vector, cipher, sizeof(vector), &sched, &iv, DES_ENCRYPT);
    DES_cbc_encrypt(cipher, plain, sizeof(vector), &sched, &iv, DES_DECRYPT);

    if (memcmp(plain, vector, sizeof(vector)) != 0)
        return -75;

    if (memcmp(cipher, verify, sizeof(verify)) != 0)
        return -76;

        /* test changing iv */
    DES_ncbc_encrypt(vector, cipher, 8, &sched, &iv, DES_ENCRYPT);
    DES_ncbc_encrypt(vector + 8, cipher + 8, 16, &sched, &iv, DES_ENCRYPT);

    if (memcmp(cipher, verify, sizeof(verify)) != 0)
        return -77;

    }  /* end des test */

#endif /* NO_DES3 */

#ifndef NO_AES

    {  /* evp_cipher test */
        EVP_CIPHER_CTX ctx;


        const byte msg[] = { /* "Now is the time for all " w/o trailing 0 */
            0x6e,0x6f,0x77,0x20,0x69,0x73,0x20,0x74,
            0x68,0x65,0x20,0x74,0x69,0x6d,0x65,0x20,
            0x66,0x6f,0x72,0x20,0x61,0x6c,0x6c,0x20
        };

        const byte verify[] =
        {
            0x95,0x94,0x92,0x57,0x5f,0x42,0x81,0x53,
            0x2c,0xcc,0x9d,0x46,0x77,0xa2,0x33,0xcb
        };

        byte key[] = "0123456789abcdef   ";  /* align */
        byte iv[]  = "1234567890abcdef   ";  /* align */

        byte cipher[AES_BLOCK_SIZE * 4];
        byte plain [AES_BLOCK_SIZE * 4];

        EVP_CIPHER_CTX_init(&ctx);
        if (EVP_CipherInit(&ctx, EVP_aes_128_cbc(), key, iv, 1) == 0)
            return -81;

        if (EVP_Cipher(&ctx, cipher, (byte*)msg, 16) == 0)
            return -82;

        if (memcmp(cipher, verify, AES_BLOCK_SIZE))
            return -83;

        EVP_CIPHER_CTX_init(&ctx);
        if (EVP_CipherInit(&ctx, EVP_aes_128_cbc(), key, iv, 0) == 0)
            return -84;

        if (EVP_Cipher(&ctx, plain, cipher, 16) == 0)
            return -85;

        if (memcmp(plain, msg, AES_BLOCK_SIZE))
            return -86;


    }  /* end evp_cipher test */

#endif /* NO_AES */

    return 0;
}

#endif /* OPENSSL_EXTRA */



#if defined(HAVE_HKDF) && (!defined(NO_SHA) || !defined(NO_SHA256))

int hkdf_test(void)
{
    int ret;
    int L = 42;
    byte okm1[42];
    byte ikm1[22] = { 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                      0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                      0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b };
    byte salt1[13] ={ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                      0x08, 0x09, 0x0a, 0x0b, 0x0c };
    byte info1[10] ={ 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
                      0xf8, 0xf9 };
    byte res1[42] = { 0x0a, 0xc1, 0xaf, 0x70, 0x02, 0xb3, 0xd7, 0x61,
                      0xd1, 0xe5, 0x52, 0x98, 0xda, 0x9d, 0x05, 0x06,
                      0xb9, 0xae, 0x52, 0x05, 0x72, 0x20, 0xa3, 0x06,
                      0xe0, 0x7b, 0x6b, 0x87, 0xe8, 0xdf, 0x21, 0xd0,
                      0xea, 0x00, 0x03, 0x3d, 0xe0, 0x39, 0x84, 0xd3,
                      0x49, 0x18 };
    byte res2[42] = { 0x08, 0x5a, 0x01, 0xea, 0x1b, 0x10, 0xf3, 0x69,
                      0x33, 0x06, 0x8b, 0x56, 0xef, 0xa5, 0xad, 0x81,
                      0xa4, 0xf1, 0x4b, 0x82, 0x2f, 0x5b, 0x09, 0x15,
                      0x68, 0xa9, 0xcd, 0xd4, 0xf1, 0x55, 0xfd, 0xa2,
                      0xc2, 0x2e, 0x42, 0x24, 0x78, 0xd3, 0x05, 0xf3,
                      0xf8, 0x96 };
    byte res3[42] = { 0x8d, 0xa4, 0xe7, 0x75, 0xa5, 0x63, 0xc1, 0x8f,
                      0x71, 0x5f, 0x80, 0x2a, 0x06, 0x3c, 0x5a, 0x31,
                      0xb8, 0xa1, 0x1f, 0x5c, 0x5e, 0xe1, 0x87, 0x9e,
                      0xc3, 0x45, 0x4e, 0x5f, 0x3c, 0x73, 0x8d, 0x2d,
                      0x9d, 0x20, 0x13, 0x95, 0xfa, 0xa4, 0xb6, 0x1a,
                      0x96, 0xc8 };
    byte res4[42] = { 0x3c, 0xb2, 0x5f, 0x25, 0xfa, 0xac, 0xd5, 0x7a,
                      0x90, 0x43, 0x4f, 0x64, 0xd0, 0x36, 0x2f, 0x2a,
                      0x2d, 0x2d, 0x0a, 0x90, 0xcf, 0x1a, 0x5a, 0x4c,
                      0x5d, 0xb0, 0x2d, 0x56, 0xec, 0xc4, 0xc5, 0xbf,
                      0x34, 0x00, 0x72, 0x08, 0xd5, 0xb8, 0x87, 0x18,
                      0x58, 0x65 };

    (void)res1;
    (void)res2;
    (void)res3;
    (void)res4;
    (void)salt1;
    (void)info1;

#ifndef NO_SHA
    ret = wc_HKDF(SHA, ikm1, 22, NULL, 0, NULL, 0, okm1, L);
    if (ret != 0)
        return -2001;

    if (memcmp(okm1, res1, L) != 0)
        return -2002;

#ifndef HAVE_FIPS
    /* fips can't have key size under 14 bytes, salt is key too */
    ret = wc_HKDF(SHA, ikm1, 11, salt1, 13, info1, 10, okm1, L);
    if (ret != 0)
        return -2003;

    if (memcmp(okm1, res2, L) != 0)
        return -2004;
#endif /* HAVE_FIPS */
#endif /* NO_SHA */

#ifndef NO_SHA256
    ret = wc_HKDF(SHA256, ikm1, 22, NULL, 0, NULL, 0, okm1, L);
    if (ret != 0)
        return -2005;

    if (memcmp(okm1, res3, L) != 0)
        return -2006;

#ifndef HAVE_FIPS
    /* fips can't have key size under 14 bytes, salt is key too */
    ret = wc_HKDF(SHA256, ikm1, 22, salt1, 13, info1, 10, okm1, L);
    if (ret != 0)
        return -2007;

    if (memcmp(okm1, res4, L) != 0)
        return -2007;
#endif /* HAVE_FIPS */
#endif /* NO_SHA256 */

    return 0;
}

#endif /* HAVE_HKDF */


#ifdef HAVE_ECC

typedef struct rawEccVector {
    const char* msg;
    const char* Qx;
    const char* Qy;
    const char* d;
    const char* R;
    const char* S;
    const char* curveName;
    size_t msgLen;
} rawEccVector;

int ecc_test(void)
{
    RNG     rng;
    byte    sharedA[1024];
    byte    sharedB[1024];
    byte    sig[1024];
    byte    digest[20];
    byte    exportBuf[1024];
    word32  x, y;
    int     i, verify, ret;
    ecc_key userA, userB, pubKey;

    ret = wc_InitRng(&rng);
    if (ret != 0)
        return -1001;

    wc_ecc_init(&userA);
    wc_ecc_init(&userB);
    wc_ecc_init(&pubKey);

    ret = wc_ecc_make_key(&rng, 32, &userA);

    if (ret != 0)
        return -1014;

    ret = wc_ecc_check_key(&userA);
    if (ret != 0)
        return -1024;

    ret = wc_ecc_make_key(&rng, 32, &userB);

    if (ret != 0)
        return -1002;

    x = sizeof(sharedA);
    ret = wc_ecc_shared_secret(&userA, &userB, sharedA, &x);

    if (ret != 0)
        return -1015;

    y = sizeof(sharedB);
    ret = wc_ecc_shared_secret(&userB, &userA, sharedB, &y);

    if (ret != 0)
        return -1003;

    if (y != x)
        return -1004;

    if (memcmp(sharedA, sharedB, x))
        return -1005;

    x = sizeof(exportBuf);
    ret = wc_ecc_export_x963(&userA, exportBuf, &x);
    if (ret != 0)
        return -1006;

    ret = wc_ecc_import_x963(exportBuf, x, &pubKey);

    if (ret != 0)
        return -1007;

    y = sizeof(sharedB);
    ret = wc_ecc_shared_secret(&userB, &pubKey, sharedB, &y);

    if (ret != 0)
        return -1008;

    if (memcmp(sharedA, sharedB, y))
        return -1009;

#ifdef HAVE_COMP_KEY
    /* try compressed export / import too */
    x = sizeof(exportBuf);
    ret = wc_ecc_export_x963_ex(&userA, exportBuf, &x, 1);
    if (ret != 0)
        return -1010;

    wc_ecc_free(&pubKey);
    wc_ecc_init(&pubKey);
    ret = wc_ecc_import_x963(exportBuf, x, &pubKey);

    if (ret != 0)
        return -1011;
#endif

    y = sizeof(sharedB);
    ret = wc_ecc_shared_secret(&userB, &pubKey, sharedB, &y);

    if (ret != 0)
        return -1012;

    if (memcmp(sharedA, sharedB, y))
        return -1013;

    /* test DSA sign hash */
    for (i = 0; i < (int)sizeof(digest); i++)
        digest[i] = (byte)i;

    x = sizeof(sig);
    ret = wc_ecc_sign_hash(digest, sizeof(digest), sig, &x, &rng, &userA);

    if (ret != 0)
        return -1014;

    verify = 0;
    ret = wc_ecc_verify_hash(sig, x, digest, sizeof(digest), &verify, &userA);

    if (ret != 0)
        return -1015;

    if (verify != 1)
        return -1016;

    x = sizeof(exportBuf);
    ret = wc_ecc_export_private_only(&userA, exportBuf, &x);
    if (ret != 0)
        return -1017;

#if !defined(NO_SHA) && \
    ((defined(HAVE_ECC192) && defined(HAVE_ECC224)) || defined(HAVE_ALL_CURVES))
    {
        /* test raw ECC key import */
        Sha sha;
        byte hash[SHA_DIGEST_SIZE];
        rawEccVector a, b;
        rawEccVector test_ecc[2];
        int times = sizeof(test_ecc) / sizeof(rawEccVector);

        /* first [P-192,SHA-1] vector from FIPS 186-3 NIST vectors */
        a.msg = "\xeb\xf7\x48\xd7\x48\xeb\xbc\xa7\xd2\x9f\xb4\x73\x69\x8a"
                "\x6e\x6b\x4f\xb1\x0c\x86\x5d\x4a\xf0\x24\xcc\x39\xae\x3d"
                "\xf3\x46\x4b\xa4\xf1\xd6\xd4\x0f\x32\xbf\x96\x18\xa9\x1b"
                "\xb5\x98\x6f\xa1\xa2\xaf\x04\x8a\x0e\x14\xdc\x51\xe5\x26"
                "\x7e\xb0\x5e\x12\x7d\x68\x9d\x0a\xc6\xf1\xa7\xf1\x56\xce"
                "\x06\x63\x16\xb9\x71\xcc\x7a\x11\xd0\xfd\x7a\x20\x93\xe2"
                "\x7c\xf2\xd0\x87\x27\xa4\xe6\x74\x8c\xc3\x2f\xd5\x9c\x78"
                "\x10\xc5\xb9\x01\x9d\xf2\x1c\xdc\xc0\xbc\xa4\x32\xc0\xa3"
                "\xee\xd0\x78\x53\x87\x50\x88\x77\x11\x43\x59\xce\xe4\xa0"
                "\x71\xcf";
        a.msgLen = 128;
        a.Qx = "07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6";
        a.Qy = "76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477";
        a.d  = "e14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3";
        a.R  = "6994d962bdd0d793ffddf855ec5bf2f91a9698b46258a63e";
        a.S  = "02ba6465a234903744ab02bc8521405b73cf5fc00e1a9f41";
        a.curveName = "ECC-192";

        /* first [P-224,SHA-1] vector from FIPS 186-3 NIST vectors */
        b.msg = "\x36\xc8\xb2\x29\x86\x48\x7f\x67\x7c\x18\xd0\x97\x2a\x9e"
                "\x20\x47\xb3\xaf\xa5\x9e\xc1\x62\x76\x4e\xc3\x0b\x5b\x69"
                "\xe0\x63\x0f\x99\x0d\x4e\x05\xc2\x73\xb0\xe5\xa9\xd4\x28"
                "\x27\xb6\x95\xfc\x2d\x64\xd9\x13\x8b\x1c\xf4\xc1\x21\x55"
                "\x89\x4c\x42\x13\x21\xa7\xbb\x97\x0b\xdc\xe0\xfb\xf0\xd2"
                "\xae\x85\x61\xaa\xd8\x71\x7f\x2e\x46\xdf\xe3\xff\x8d\xea"
                "\xb4\xd7\x93\x23\x56\x03\x2c\x15\x13\x0d\x59\x9e\x26\xc1"
                "\x0f\x2f\xec\x96\x30\x31\xac\x69\x38\xa1\x8d\x66\x45\x38"
                "\xb9\x4d\xac\x55\x34\xef\x7b\x59\x94\x24\xd6\x9b\xe1\xf7"
                "\x1c\x20";
        b.msgLen = 128;
        b.Qx = "8a4dca35136c4b70e588e23554637ae251077d1365a6ba5db9585de7";
        b.Qy = "ad3dee06de0be8279d4af435d7245f14f3b4f82eb578e519ee0057b1";
        b.d  = "97c4b796e1639dd1035b708fc00dc7ba1682cec44a1002a1a820619f";
        b.R  = "147b33758321e722a0360a4719738af848449e2c1d08defebc1671a7";
        b.S  = "24fc7ed7f1352ca3872aa0916191289e2e04d454935d50fe6af3ad5b";
        b.curveName = "ECC-224";

        test_ecc[0] = a;
        test_ecc[1] = b;

        for (i = 0; i < times; i++) {

            wc_ecc_free(&userA);
            wc_ecc_init(&userA);

            memset(sig, 0, sizeof(sig));
            x = sizeof(sig);

            /* calculate SHA-1 hash of message */
            ret = wc_InitSha(&sha);
            if (ret != 0)
                return -1015 - i;

            wc_ShaUpdate(&sha, (byte*)test_ecc[i].msg, (word32)test_ecc[i].msgLen);
            wc_ShaFinal(&sha, hash);

            ret = wc_ecc_import_raw(&userA, test_ecc[i].Qx, test_ecc[i].Qy,
                                 test_ecc[i].d, test_ecc[i].curveName);
            if (ret != 0)
                return -1017 - i;

            ret = wc_ecc_rs_to_sig(test_ecc[i].R, test_ecc[i].S, sig, &x);
            if (ret != 0)
                return -1019 - i;

            ret = wc_ecc_verify_hash(sig, x, hash, sizeof(hash), &verify, &userA);
            if (ret != 0)
                return -1021 - i;

            if (verify != 1)
                return -1023 - i;
        }
    }
#endif /* defined(HAVE_ECC192) && defined(HAVE_ECC256) */


#ifdef WOLFSSL_KEY_GEN
    {
        int   derSz, pemSz;
        byte  der[FOURK_BUF];
        byte  pem[FOURK_BUF];
        FILE* keyFile;
        FILE* pemFile;

        derSz = wc_EccKeyToDer(&userB, der, FOURK_BUF);
        if (derSz < 0) {
            return -1024;
        }

        keyFile = fopen("./ecc-key.der", "wb");
        if (!keyFile) {
            return -1025;
        }
        ret = (int)fwrite(der, 1, derSz, keyFile);
        fclose(keyFile);
        if (ret != derSz) {
            return -1026;
        }

        pemSz = wc_DerToPem(der, derSz, pem, FOURK_BUF, ECC_PRIVATEKEY_TYPE);
        if (pemSz < 0) {
            return -1027;
        }

        pemFile = fopen("./ecc-key.pem", "wb");
        if (!pemFile) {
            return -1028;
        }
        ret = (int)fwrite(pem, 1, pemSz, pemFile);
        fclose(pemFile);
        if (ret != pemSz) {
            return -1029;
        }
    }
#endif /* WOLFSSL_KEY_GEN */

    wc_ecc_free(&pubKey);
    wc_ecc_free(&userB);
    wc_ecc_free(&userA);
    wc_FreeRng(&rng);

    return 0;
}

#ifdef HAVE_ECC_ENCRYPT

int ecc_encrypt_test(void)
{
    RNG     rng;
    int     ret;
    ecc_key userA, userB;
    byte    msg[48];
    byte    plain[48];
    byte    out[80];
    word32  outSz   = sizeof(out);
    word32  plainSz = sizeof(plain);
    int     i;

    ret = wc_InitRng(&rng);
    if (ret != 0)
        return -3001;

    wc_ecc_init(&userA);
    wc_ecc_init(&userB);

    ret  = wc_ecc_make_key(&rng, 32, &userA);
    ret += wc_ecc_make_key(&rng, 32, &userB);

    if (ret != 0)
        return -3002;

    for (i = 0; i < 48; i++)
        msg[i] = i;

    /* encrypt msg to B */
    ret = wc_ecc_encrypt(&userA, &userB, msg, sizeof(msg), out, &outSz, NULL);
    if (ret != 0)
        return -3003;

    /* decrypt msg from A */
    ret = wc_ecc_decrypt(&userB, &userA, out, outSz, plain, &plainSz, NULL);
    if (ret != 0)
        return -3004;

    if (memcmp(plain, msg, sizeof(msg)) != 0)
        return -3005;


    {  /* let's verify message exchange works, A is client, B is server */
        ecEncCtx* cliCtx = wc_ecc_ctx_new(REQ_RESP_CLIENT, &rng);
        ecEncCtx* srvCtx = wc_ecc_ctx_new(REQ_RESP_SERVER, &rng);

        byte cliSalt[EXCHANGE_SALT_SZ];
        byte srvSalt[EXCHANGE_SALT_SZ];
        const byte* tmpSalt;

        if (cliCtx == NULL || srvCtx == NULL)
            return -3006;

        /* get salt to send to peer */
        tmpSalt = wc_ecc_ctx_get_own_salt(cliCtx);
        if (tmpSalt == NULL)
            return -3007;
        memcpy(cliSalt, tmpSalt, EXCHANGE_SALT_SZ);

        tmpSalt = wc_ecc_ctx_get_own_salt(srvCtx);
        if (tmpSalt == NULL)
            return -3007;
        memcpy(srvSalt, tmpSalt, EXCHANGE_SALT_SZ);

        /* in actual use, we'd get the peer's salt over the transport */
        ret  = wc_ecc_ctx_set_peer_salt(cliCtx, srvSalt);
        ret += wc_ecc_ctx_set_peer_salt(srvCtx, cliSalt);

        ret += wc_ecc_ctx_set_info(cliCtx, (byte*)"wolfSSL MSGE", 11);
        ret += wc_ecc_ctx_set_info(srvCtx, (byte*)"wolfSSL MSGE", 11);

        if (ret != 0)
            return -3008;

        /* get encrypted msg (request) to send to B */
        outSz  = sizeof(out);
        ret = wc_ecc_encrypt(&userA, &userB, msg, sizeof(msg), out, &outSz,cliCtx);
        if (ret != 0)
            return -3009;

        /* B decrypts msg (request) from A */
        plainSz = sizeof(plain);
        ret = wc_ecc_decrypt(&userB, &userA, out, outSz, plain, &plainSz, srvCtx);
        if (ret != 0)
            return -3010;

        if (memcmp(plain, msg, sizeof(msg)) != 0)
            return -3011;

        {
            /* msg2 (response) from B to A */
            byte    msg2[48];
            byte    plain2[48];
            byte    out2[80];
            word32  outSz2   = sizeof(out2);
            word32  plainSz2 = sizeof(plain2);

            for (i = 0; i < 48; i++)
                msg2[i] = i+48;

            /* get encrypted msg (response) to send to B */
            ret = wc_ecc_encrypt(&userB, &userA, msg2, sizeof(msg2), out2,
                              &outSz2, srvCtx);
            if (ret != 0)
                return -3012;

            /* A decrypts msg (response) from B */
            ret = wc_ecc_decrypt(&userA, &userB, out2, outSz2, plain2, &plainSz2,
                             cliCtx);
            if (ret != 0)
                return -3013;

            if (memcmp(plain2, msg2, sizeof(msg2)) != 0)
                return -3014;
        }

        /* cleanup */
        wc_ecc_ctx_free(srvCtx);
        wc_ecc_ctx_free(cliCtx);
    }

    /* cleanup */
    wc_ecc_free(&userB);
    wc_ecc_free(&userA);
    wc_FreeRng(&rng);

    return 0;
}

#endif /* HAVE_ECC_ENCRYPT */
#endif /* HAVE_ECC */


#ifdef HAVE_CURVE25519

int curve25519_test(void)
{
    RNG     rng;
    byte    sharedA[32];
    byte    sharedB[32];
    byte    exportBuf[32];
    word32  x, y;
    curve25519_key userA, userB, pubKey;

    /* test vectors from
       https://tools.ietf.org/html/draft-josefsson-tls-curve25519-03
     */

    /* secret key for party a */
    byte sa[] = {
        0x5A,0xC9,0x9F,0x33,0x63,0x2E,0x5A,0x76,
        0x8D,0xE7,0xE8,0x1B,0xF8,0x54,0xC2,0x7C,
        0x46,0xE3,0xFB,0xF2,0xAB,0xBA,0xCD,0x29,
        0xEC,0x4A,0xFF,0x51,0x73,0x69,0xC6,0x60
    };

    /* public key for party a */
    byte pa[] = {
        0x05,0x7E,0x23,0xEA,0x9F,0x1C,0xBE,0x8A,
        0x27,0x16,0x8F,0x6E,0x69,0x6A,0x79,0x1D,
        0xE6,0x1D,0xD3,0xAF,0x7A,0xCD,0x4E,0xEA,
        0xCC,0x6E,0x7B,0xA5,0x14,0xFD,0xA8,0x63
    };

    /* secret key for party b */
    byte sb[] = {
        0x47,0xDC,0x3D,0x21,0x41,0x74,0x82,0x0E,
        0x11,0x54,0xB4,0x9B,0xC6,0xCD,0xB2,0xAB,
        0xD4,0x5E,0xE9,0x58,0x17,0x05,0x5D,0x25,
        0x5A,0xA3,0x58,0x31,0xB7,0x0D,0x32,0x60
    };

    /* public key for party b */
    byte pb[] = {
        0x6E,0xB8,0x9D,0xA9,0x19,0x89,0xAE,0x37,
        0xC7,0xEA,0xC7,0x61,0x8D,0x9E,0x5C,0x49,
        0x51,0xDB,0xA1,0xD7,0x3C,0x28,0x5A,0xE1,
        0xCD,0x26,0xA8,0x55,0x02,0x0E,0xEF,0x04
    };

    /* expected shared key */
    byte ss[] = {
        0x61,0x45,0x0C,0xD9,0x8E,0x36,0x01,0x6B,
        0x58,0x77,0x6A,0x89,0x7A,0x9F,0x0A,0xEF,
        0x73,0x8B,0x99,0xF0,0x94,0x68,0xB8,0xD6,
        0xB8,0x51,0x11,0x84,0xD5,0x34,0x94,0xAB
    };

    if (wc_InitRng(&rng) != 0)
        return -1001;

    wc_curve25519_init(&userA);
    wc_curve25519_init(&userB);
    wc_curve25519_init(&pubKey);

    /* make curve25519 keys */
    if (wc_curve25519_make_key(&rng, 32, &userA) != 0)
        return -1002;

    if (wc_curve25519_make_key(&rng, 32, &userB) != 0)
        return -1003;

    /* find shared secret key */
    if (wc_curve25519_shared_secret(&userA, &userB, sharedA, &x) != 0)
        return -1004;

    if (wc_curve25519_shared_secret(&userB, &userA, sharedB, &y) != 0)
        return -1005;

    /* compare shared secret keys to test they are the same */
    if (y != x)
        return -1006;

    if (XMEMCMP(sharedA, sharedB, x))
        return -1007;

    /* export a public key and import it for another user */
    if (wc_curve25519_export_public(&userA, exportBuf, &x) != 0)
        return -1008;

    if (wc_curve25519_import_public(exportBuf, x, &pubKey) != 0)
        return -1009;

    /* test shared key after importing a public key */
    XMEMSET(sharedB, 0, sizeof(sharedB));
    if (wc_curve25519_shared_secret(&userB, &pubKey, sharedB, &y) != 0)
        return -1010;

    if (XMEMCMP(sharedA, sharedB, y))
        return -1011;

    /* import RFC test vectors and compare shared key */
    if (wc_curve25519_import_private_raw(sa, sizeof(sa), pa, sizeof(pa), &userA)
            != 0)
        return -1012;

    if (wc_curve25519_import_private_raw(sb, sizeof(sb), pb, sizeof(pb), &userB)
            != 0)
        return -1013;

    /* test against known test vector */
    XMEMSET(sharedB, 0, sizeof(sharedB));
    if (wc_curve25519_shared_secret(&userA, &userB, sharedB, &y) != 0)
        return -1014;

    if (XMEMCMP(ss, sharedB, y))
        return -1015;

    /* test swaping roles of keys and generating same shared key */
    XMEMSET(sharedB, 0, sizeof(sharedB));
    if (wc_curve25519_shared_secret(&userB, &userA, sharedB, &y) != 0)
        return -1016;

    if (XMEMCMP(ss, sharedB, y))
        return -1017;

    /* clean up keys when done */
    wc_curve25519_free(&pubKey);
    wc_curve25519_free(&userB);
    wc_curve25519_free(&userA);

    wc_FreeRng(&rng);

    return 0;
}
#endif /* HAVE_CURVE25519 */


#ifdef HAVE_ED25519
int ed25519_test(void)
{
    RNG    rng;
    byte   out[ED25519_SIG_SIZE];
    byte   exportPKey[ED25519_KEY_SIZE];
    byte   exportSKey[ED25519_KEY_SIZE];
    word32 outlen;
    word32 exportPSz;
    word32 exportSSz;
    word32 keySz, sigSz;
    int    i, verify;
    ed25519_key key;
    ed25519_key key2;

    /* test vectors from
       https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-02
     */

    const byte sKey1[] = {
		0x9d,0x61,0xb1,0x9d,0xef,0xfd,0x5a,0x60,
		0xba,0x84,0x4a,0xf4,0x92,0xec,0x2c,0xc4,
		0x44,0x49,0xc5,0x69,0x7b,0x32,0x69,0x19,
		0x70,0x3b,0xac,0x03,0x1c,0xae,0x7f,0x60
    };

    const byte sKey2[] = {
		0x4c,0xcd,0x08,0x9b,0x28,0xff,0x96,0xda,
		0x9d,0xb6,0xc3,0x46,0xec,0x11,0x4e,0x0f,
		0x5b,0x8a,0x31,0x9f,0x35,0xab,0xa6,0x24,
		0xda,0x8c,0xf6,0xed,0x4f,0xb8,0xa6,0xfb
    };

    const byte sKey3[] = {
		0xc5,0xaa,0x8d,0xf4,0x3f,0x9f,0x83,0x7b,
		0xed,0xb7,0x44,0x2f,0x31,0xdc,0xb7,0xb1,
		0x66,0xd3,0x85,0x35,0x07,0x6f,0x09,0x4b,
		0x85,0xce,0x3a,0x2e,0x0b,0x44,0x58,0xf7
    };

    /* uncompressed test */
    const byte sKey4[] = {
		0x9d,0x61,0xb1,0x9d,0xef,0xfd,0x5a,0x60,
		0xba,0x84,0x4a,0xf4,0x92,0xec,0x2c,0xc4,
		0x44,0x49,0xc5,0x69,0x7b,0x32,0x69,0x19,
		0x70,0x3b,0xac,0x03,0x1c,0xae,0x7f,0x60
    };

    /* compressed prefix test */
    const byte sKey5[] = {
		0x9d,0x61,0xb1,0x9d,0xef,0xfd,0x5a,0x60,
		0xba,0x84,0x4a,0xf4,0x92,0xec,0x2c,0xc4,
		0x44,0x49,0xc5,0x69,0x7b,0x32,0x69,0x19,
		0x70,0x3b,0xac,0x03,0x1c,0xae,0x7f,0x60
    };

    const byte sKey6[] = {
		0xf5,0xe5,0x76,0x7c,0xf1,0x53,0x31,0x95,
		0x17,0x63,0x0f,0x22,0x68,0x76,0xb8,0x6c,
		0x81,0x60,0xcc,0x58,0x3b,0xc0,0x13,0x74,
		0x4c,0x6b,0xf2,0x55,0xf5,0xcc,0x0e,0xe5
    };

    const byte* sKeys[] = {sKey1, sKey2, sKey3, sKey4, sKey5, sKey6};

    const byte pKey1[] = {
		0xd7,0x5a,0x98,0x01,0x82,0xb1,0x0a,0xb7,
		0xd5,0x4b,0xfe,0xd3,0xc9,0x64,0x07,0x3a,
		0x0e,0xe1,0x72,0xf3,0xda,0xa6,0x23,0x25,
		0xaf,0x02,0x1a,0x68,0xf7,0x07,0x51,0x1a
    };

    const byte pKey2[] = {
		0x3d,0x40,0x17,0xc3,0xe8,0x43,0x89,0x5a,
		0x92,0xb7,0x0a,0xa7,0x4d,0x1b,0x7e,0xbc,
        0x9c,0x98,0x2c,0xcf,0x2e,0xc4,0x96,0x8c,
		0xc0,0xcd,0x55,0xf1,0x2a,0xf4,0x66,0x0c
    };

    const byte pKey3[] = {
		0xfc,0x51,0xcd,0x8e,0x62,0x18,0xa1,0xa3,
		0x8d,0xa4,0x7e,0xd0,0x02,0x30,0xf0,0x58,
		0x08,0x16,0xed,0x13,0xba,0x33,0x03,0xac,
		0x5d,0xeb,0x91,0x15,0x48,0x90,0x80,0x25
    };

    /* uncompressed test */
    const byte pKey4[] = {
		0x04,0x55,0xd0,0xe0,0x9a,0x2b,0x9d,0x34,
		0x29,0x22,0x97,0xe0,0x8d,0x60,0xd0,0xf6,
		0x20,0xc5,0x13,0xd4,0x72,0x53,0x18,0x7c,
		0x24,0xb1,0x27,0x86,0xbd,0x77,0x76,0x45,
		0xce,0x1a,0x51,0x07,0xf7,0x68,0x1a,0x02,
		0xaf,0x25,0x23,0xa6,0xda,0xf3,0x72,0xe1,
		0x0e,0x3a,0x07,0x64,0xc9,0xd3,0xfe,0x4b,
		0xd5,0xb7,0x0a,0xb1,0x82,0x01,0x98,0x5a,
		0xd7
    };

    /* compressed prefix */
    const byte pKey5[] = {
		0x40,0xd7,0x5a,0x98,0x01,0x82,0xb1,0x0a,0xb7,
		0xd5,0x4b,0xfe,0xd3,0xc9,0x64,0x07,0x3a,
		0x0e,0xe1,0x72,0xf3,0xda,0xa6,0x23,0x25,
		0xaf,0x02,0x1a,0x68,0xf7,0x07,0x51,0x1a
    };

    const byte pKey6[] = {
		0x27,0x81,0x17,0xfc,0x14,0x4c,0x72,0x34,
		0x0f,0x67,0xd0,0xf2,0x31,0x6e,0x83,0x86,
		0xce,0xff,0xbf,0x2b,0x24,0x28,0xc9,0xc5,
		0x1f,0xef,0x7c,0x59,0x7f,0x1d,0x42,0x6e
    };

    const byte* pKeys[] = {pKey1, pKey2, pKey3, pKey4, pKey5, pKey6};
    const byte  pKeySz[] = {sizeof(pKey1), sizeof(pKey2), sizeof(pKey3),
                            sizeof(pKey4), sizeof(pKey5), sizeof(pKey6)};

    const byte sig1[] = {
		0xe5,0x56,0x43,0x00,0xc3,0x60,0xac,0x72,
		0x90,0x86,0xe2,0xcc,0x80,0x6e,0x82,0x8a,
		0x84,0x87,0x7f,0x1e,0xb8,0xe5,0xd9,0x74,
		0xd8,0x73,0xe0,0x65,0x22,0x49,0x01,0x55,
		0x5f,0xb8,0x82,0x15,0x90,0xa3,0x3b,0xac,
		0xc6,0x1e,0x39,0x70,0x1c,0xf9,0xb4,0x6b,
		0xd2,0x5b,0xf5,0xf0,0x59,0x5b,0xbe,0x24,
		0x65,0x51,0x41,0x43,0x8e,0x7a,0x10,0x0b
    };

    const byte sig2[] = {
		0x92,0xa0,0x09,0xa9,0xf0,0xd4,0xca,0xb8,
		0x72,0x0e,0x82,0x0b,0x5f,0x64,0x25,0x40,
		0xa2,0xb2,0x7b,0x54,0x16,0x50,0x3f,0x8f,
		0xb3,0x76,0x22,0x23,0xeb,0xdb,0x69,0xda,
		0x08,0x5a,0xc1,0xe4,0x3e,0x15,0x99,0x6e,
		0x45,0x8f,0x36,0x13,0xd0,0xf1,0x1d,0x8c,
		0x38,0x7b,0x2e,0xae,0xb4,0x30,0x2a,0xee,
		0xb0,0x0d,0x29,0x16,0x12,0xbb,0x0c,0x00
    };

    const byte sig3[] = {
		0x62,0x91,0xd6,0x57,0xde,0xec,0x24,0x02,
		0x48,0x27,0xe6,0x9c,0x3a,0xbe,0x01,0xa3,
		0x0c,0xe5,0x48,0xa2,0x84,0x74,0x3a,0x44,
		0x5e,0x36,0x80,0xd7,0xdb,0x5a,0xc3,0xac,
		0x18,0xff,0x9b,0x53,0x8d,0x16,0xf2,0x90,
		0xae,0x67,0xf7,0x60,0x98,0x4d,0xc6,0x59,
		0x4a,0x7c,0x15,0xe9,0x71,0x6e,0xd2,0x8d,
		0xc0,0x27,0xbe,0xce,0xea,0x1e,0xc4,0x0a
    };

    /* uncompressed test */
    const byte sig4[] = {
		0xe5,0x56,0x43,0x00,0xc3,0x60,0xac,0x72,
		0x90,0x86,0xe2,0xcc,0x80,0x6e,0x82,0x8a,
		0x84,0x87,0x7f,0x1e,0xb8,0xe5,0xd9,0x74,
		0xd8,0x73,0xe0,0x65,0x22,0x49,0x01,0x55,
		0x5f,0xb8,0x82,0x15,0x90,0xa3,0x3b,0xac,
		0xc6,0x1e,0x39,0x70,0x1c,0xf9,0xb4,0x6b,
		0xd2,0x5b,0xf5,0xf0,0x59,0x5b,0xbe,0x24,
		0x65,0x51,0x41,0x43,0x8e,0x7a,0x10,0x0b
    };

    /* compressed prefix */
    const byte sig5[] = {
		0xe5,0x56,0x43,0x00,0xc3,0x60,0xac,0x72,
		0x90,0x86,0xe2,0xcc,0x80,0x6e,0x82,0x8a,
		0x84,0x87,0x7f,0x1e,0xb8,0xe5,0xd9,0x74,
		0xd8,0x73,0xe0,0x65,0x22,0x49,0x01,0x55,
		0x5f,0xb8,0x82,0x15,0x90,0xa3,0x3b,0xac,
		0xc6,0x1e,0x39,0x70,0x1c,0xf9,0xb4,0x6b,
		0xd2,0x5b,0xf5,0xf0,0x59,0x5b,0xbe,0x24,
		0x65,0x51,0x41,0x43,0x8e,0x7a,0x10,0x0b
    };

    const byte sig6[] = {
		0x0a,0xab,0x4c,0x90,0x05,0x01,0xb3,0xe2,
		0x4d,0x7c,0xdf,0x46,0x63,0x32,0x6a,0x3a,
		0x87,0xdf,0x5e,0x48,0x43,0xb2,0xcb,0xdb,
		0x67,0xcb,0xf6,0xe4,0x60,0xfe,0xc3,0x50,
		0xaa,0x53,0x71,0xb1,0x50,0x8f,0x9f,0x45,
		0x28,0xec,0xea,0x23,0xc4,0x36,0xd9,0x4b,
		0x5e,0x8f,0xcd,0x4f,0x68,0x1e,0x30,0xa6,
		0xac,0x00,0xa9,0x70,0x4a,0x18,0x8a,0x03
    };

    const byte* sigs[] = {sig1, sig2, sig3, sig4, sig5, sig6};

    const byte msg1[]  = {};
    const byte msg2[]  = {0x72};
    const byte msg3[]  = {0xAF,0x82};

    /* test of a 1024 byte long message */
    const byte msg4[]  = {
		0x08,0xb8,0xb2,0xb7,0x33,0x42,0x42,0x43,
		0x76,0x0f,0xe4,0x26,0xa4,0xb5,0x49,0x08,
		0x63,0x21,0x10,0xa6,0x6c,0x2f,0x65,0x91,
		0xea,0xbd,0x33,0x45,0xe3,0xe4,0xeb,0x98,
		0xfa,0x6e,0x26,0x4b,0xf0,0x9e,0xfe,0x12,
		0xee,0x50,0xf8,0xf5,0x4e,0x9f,0x77,0xb1,
		0xe3,0x55,0xf6,0xc5,0x05,0x44,0xe2,0x3f,
		0xb1,0x43,0x3d,0xdf,0x73,0xbe,0x84,0xd8,
		0x79,0xde,0x7c,0x00,0x46,0xdc,0x49,0x96,
		0xd9,0xe7,0x73,0xf4,0xbc,0x9e,0xfe,0x57,
		0x38,0x82,0x9a,0xdb,0x26,0xc8,0x1b,0x37,
		0xc9,0x3a,0x1b,0x27,0x0b,0x20,0x32,0x9d,
		0x65,0x86,0x75,0xfc,0x6e,0xa5,0x34,0xe0,
		0x81,0x0a,0x44,0x32,0x82,0x6b,0xf5,0x8c,
		0x94,0x1e,0xfb,0x65,0xd5,0x7a,0x33,0x8b,
		0xbd,0x2e,0x26,0x64,0x0f,0x89,0xff,0xbc,
		0x1a,0x85,0x8e,0xfc,0xb8,0x55,0x0e,0xe3,
		0xa5,0xe1,0x99,0x8b,0xd1,0x77,0xe9,0x3a,
		0x73,0x63,0xc3,0x44,0xfe,0x6b,0x19,0x9e,
		0xe5,0xd0,0x2e,0x82,0xd5,0x22,0xc4,0xfe,
		0xba,0x15,0x45,0x2f,0x80,0x28,0x8a,0x82,
		0x1a,0x57,0x91,0x16,0xec,0x6d,0xad,0x2b,
		0x3b,0x31,0x0d,0xa9,0x03,0x40,0x1a,0xa6,
		0x21,0x00,0xab,0x5d,0x1a,0x36,0x55,0x3e,
		0x06,0x20,0x3b,0x33,0x89,0x0c,0xc9,0xb8,
		0x32,0xf7,0x9e,0xf8,0x05,0x60,0xcc,0xb9,
		0xa3,0x9c,0xe7,0x67,0x96,0x7e,0xd6,0x28,
		0xc6,0xad,0x57,0x3c,0xb1,0x16,0xdb,0xef,
		0xef,0xd7,0x54,0x99,0xda,0x96,0xbd,0x68,
		0xa8,0xa9,0x7b,0x92,0x8a,0x8b,0xbc,0x10,
		0x3b,0x66,0x21,0xfc,0xde,0x2b,0xec,0xa1,
		0x23,0x1d,0x20,0x6b,0xe6,0xcd,0x9e,0xc7,
		0xaf,0xf6,0xf6,0xc9,0x4f,0xcd,0x72,0x04,
		0xed,0x34,0x55,0xc6,0x8c,0x83,0xf4,0xa4,
		0x1d,0xa4,0xaf,0x2b,0x74,0xef,0x5c,0x53,
		0xf1,0xd8,0xac,0x70,0xbd,0xcb,0x7e,0xd1,
		0x85,0xce,0x81,0xbd,0x84,0x35,0x9d,0x44,
		0x25,0x4d,0x95,0x62,0x9e,0x98,0x55,0xa9,
		0x4a,0x7c,0x19,0x58,0xd1,0xf8,0xad,0xa5,
		0xd0,0x53,0x2e,0xd8,0xa5,0xaa,0x3f,0xb2,
		0xd1,0x7b,0xa7,0x0e,0xb6,0x24,0x8e,0x59,
		0x4e,0x1a,0x22,0x97,0xac,0xbb,0xb3,0x9d,
		0x50,0x2f,0x1a,0x8c,0x6e,0xb6,0xf1,0xce,
		0x22,0xb3,0xde,0x1a,0x1f,0x40,0xcc,0x24,
		0x55,0x41,0x19,0xa8,0x31,0xa9,0xaa,0xd6,
		0x07,0x9c,0xad,0x88,0x42,0x5d,0xe6,0xbd,
		0xe1,0xa9,0x18,0x7e,0xbb,0x60,0x92,0xcf,
		0x67,0xbf,0x2b,0x13,0xfd,0x65,0xf2,0x70,
		0x88,0xd7,0x8b,0x7e,0x88,0x3c,0x87,0x59,
		0xd2,0xc4,0xf5,0xc6,0x5a,0xdb,0x75,0x53,
		0x87,0x8a,0xd5,0x75,0xf9,0xfa,0xd8,0x78,
		0xe8,0x0a,0x0c,0x9b,0xa6,0x3b,0xcb,0xcc,
		0x27,0x32,0xe6,0x94,0x85,0xbb,0xc9,0xc9,
		0x0b,0xfb,0xd6,0x24,0x81,0xd9,0x08,0x9b,
		0xec,0xcf,0x80,0xcf,0xe2,0xdf,0x16,0xa2,
		0xcf,0x65,0xbd,0x92,0xdd,0x59,0x7b,0x07,
		0x07,0xe0,0x91,0x7a,0xf4,0x8b,0xbb,0x75,
		0xfe,0xd4,0x13,0xd2,0x38,0xf5,0x55,0x5a,
		0x7a,0x56,0x9d,0x80,0xc3,0x41,0x4a,0x8d,
		0x08,0x59,0xdc,0x65,0xa4,0x61,0x28,0xba,
		0xb2,0x7a,0xf8,0x7a,0x71,0x31,0x4f,0x31,
		0x8c,0x78,0x2b,0x23,0xeb,0xfe,0x80,0x8b,
		0x82,0xb0,0xce,0x26,0x40,0x1d,0x2e,0x22,
		0xf0,0x4d,0x83,0xd1,0x25,0x5d,0xc5,0x1a,
		0xdd,0xd3,0xb7,0x5a,0x2b,0x1a,0xe0,0x78,
		0x45,0x04,0xdf,0x54,0x3a,0xf8,0x96,0x9b,
		0xe3,0xea,0x70,0x82,0xff,0x7f,0xc9,0x88,
		0x8c,0x14,0x4d,0xa2,0xaf,0x58,0x42,0x9e,
		0xc9,0x60,0x31,0xdb,0xca,0xd3,0xda,0xd9,
		0xaf,0x0d,0xcb,0xaa,0xaf,0x26,0x8c,0xb8,
		0xfc,0xff,0xea,0xd9,0x4f,0x3c,0x7c,0xa4,
		0x95,0xe0,0x56,0xa9,0xb4,0x7a,0xcd,0xb7,
		0x51,0xfb,0x73,0xe6,0x66,0xc6,0xc6,0x55,
		0xad,0xe8,0x29,0x72,0x97,0xd0,0x7a,0xd1,
		0xba,0x5e,0x43,0xf1,0xbc,0xa3,0x23,0x01,
		0x65,0x13,0x39,0xe2,0x29,0x04,0xcc,0x8c,
		0x42,0xf5,0x8c,0x30,0xc0,0x4a,0xaf,0xdb,
		0x03,0x8d,0xda,0x08,0x47,0xdd,0x98,0x8d,
		0xcd,0xa6,0xf3,0xbf,0xd1,0x5c,0x4b,0x4c,
		0x45,0x25,0x00,0x4a,0xa0,0x6e,0xef,0xf8,
		0xca,0x61,0x78,0x3a,0xac,0xec,0x57,0xfb,
		0x3d,0x1f,0x92,0xb0,0xfe,0x2f,0xd1,0xa8,
		0x5f,0x67,0x24,0x51,0x7b,0x65,0xe6,0x14,
		0xad,0x68,0x08,0xd6,0xf6,0xee,0x34,0xdf,
		0xf7,0x31,0x0f,0xdc,0x82,0xae,0xbf,0xd9,
		0x04,0xb0,0x1e,0x1d,0xc5,0x4b,0x29,0x27,
		0x09,0x4b,0x2d,0xb6,0x8d,0x6f,0x90,0x3b,
		0x68,0x40,0x1a,0xde,0xbf,0x5a,0x7e,0x08,
		0xd7,0x8f,0xf4,0xef,0x5d,0x63,0x65,0x3a,
		0x65,0x04,0x0c,0xf9,0xbf,0xd4,0xac,0xa7,
		0x98,0x4a,0x74,0xd3,0x71,0x45,0x98,0x67,
		0x80,0xfc,0x0b,0x16,0xac,0x45,0x16,0x49,
		0xde,0x61,0x88,0xa7,0xdb,0xdf,0x19,0x1f,
		0x64,0xb5,0xfc,0x5e,0x2a,0xb4,0x7b,0x57,
		0xf7,0xf7,0x27,0x6c,0xd4,0x19,0xc1,0x7a,
		0x3c,0xa8,0xe1,0xb9,0x39,0xae,0x49,0xe4,
		0x88,0xac,0xba,0x6b,0x96,0x56,0x10,0xb5,
		0x48,0x01,0x09,0xc8,0xb1,0x7b,0x80,0xe1,
		0xb7,0xb7,0x50,0xdf,0xc7,0x59,0x8d,0x5d,
		0x50,0x11,0xfd,0x2d,0xcc,0x56,0x00,0xa3,
		0x2e,0xf5,0xb5,0x2a,0x1e,0xcc,0x82,0x0e,
		0x30,0x8a,0xa3,0x42,0x72,0x1a,0xac,0x09,
		0x43,0xbf,0x66,0x86,0xb6,0x4b,0x25,0x79,
		0x37,0x65,0x04,0xcc,0xc4,0x93,0xd9,0x7e,
		0x6a,0xed,0x3f,0xb0,0xf9,0xcd,0x71,0xa4,
		0x3d,0xd4,0x97,0xf0,0x1f,0x17,0xc0,0xe2,
		0xcb,0x37,0x97,0xaa,0x2a,0x2f,0x25,0x66,
		0x56,0x16,0x8e,0x6c,0x49,0x6a,0xfc,0x5f,
		0xb9,0x32,0x46,0xf6,0xb1,0x11,0x63,0x98,
		0xa3,0x46,0xf1,0xa6,0x41,0xf3,0xb0,0x41,
		0xe9,0x89,0xf7,0x91,0x4f,0x90,0xcc,0x2c,
		0x7f,0xff,0x35,0x78,0x76,0xe5,0x06,0xb5,
		0x0d,0x33,0x4b,0xa7,0x7c,0x22,0x5b,0xc3,
		0x07,0xba,0x53,0x71,0x52,0xf3,0xf1,0x61,
		0x0e,0x4e,0xaf,0xe5,0x95,0xf6,0xd9,0xd9,
		0x0d,0x11,0xfa,0xa9,0x33,0xa1,0x5e,0xf1,
		0x36,0x95,0x46,0x86,0x8a,0x7f,0x3a,0x45,
		0xa9,0x67,0x68,0xd4,0x0f,0xd9,0xd0,0x34,
		0x12,0xc0,0x91,0xc6,0x31,0x5c,0xf4,0xfd,
		0xe7,0xcb,0x68,0x60,0x69,0x37,0x38,0x0d,
		0xb2,0xea,0xaa,0x70,0x7b,0x4c,0x41,0x85,
		0xc3,0x2e,0xdd,0xcd,0xd3,0x06,0x70,0x5e,
		0x4d,0xc1,0xff,0xc8,0x72,0xee,0xee,0x47,
		0x5a,0x64,0xdf,0xac,0x86,0xab,0xa4,0x1c,
		0x06,0x18,0x98,0x3f,0x87,0x41,0xc5,0xef,
		0x68,0xd3,0xa1,0x01,0xe8,0xa3,0xb8,0xca,
		0xc6,0x0c,0x90,0x5c,0x15,0xfc,0x91,0x08,
		0x40,0xb9,0x4c,0x00,0xa0,0xb9,0xd0
    };

    const byte* msgs[] = {msg1, msg2, msg3, msg1, msg1, msg4};
    const word16 msgSz[] = {sizeof(msg1), sizeof(msg2), sizeof(msg3),
                            sizeof(msg1), sizeof(msg1), sizeof(msg4)};

    /* create ed25519 keys */
    wc_InitRng(&rng);
    wc_ed25519_init(&key);
    wc_ed25519_init(&key2);
    wc_ed25519_make_key(&rng, ED25519_KEY_SIZE, &key);
    wc_ed25519_make_key(&rng, ED25519_KEY_SIZE, &key2);

    /* helper functions for signature and key size */
    keySz = wc_ed25519_size(&key);
    sigSz = wc_ed25519_sig_size(&key);

    for (i = 0; i < 6; i++) {
        outlen = sizeof(out);
        XMEMSET(out, 0, sizeof(out));

        if (wc_ed25519_import_private_key(sKeys[i], ED25519_KEY_SIZE, pKeys[i],
                pKeySz[i], &key) != 0)
            return -1021 - i;

        if (wc_ed25519_sign_msg(msgs[i], msgSz[i], out, &outlen, &key)
                != 0)
            return -1027 - i;

        if (XMEMCMP(out, sigs[i], 64))
            return -1033 - i;

        /* test verify on good msg */
        if (wc_ed25519_verify_msg(out, outlen, msgs[i], msgSz[i], &verify,
                    &key) != 0 || verify != 1)
            return -1039 - i;

        /* test verify on bad msg */
        out[outlen-1] = out[outlen-1] + 1;
        if (wc_ed25519_verify_msg(out, outlen, msgs[i], msgSz[i], &verify,
                    &key) == 0 || verify == 1)
            return -1045 - i;

        /* test api for import/exporting keys */
        exportPSz = sizeof(exportPKey);
        exportSSz = sizeof(exportSKey);
        if (wc_ed25519_export_public(&key, exportPKey, &exportPSz) != 0)
            return -1051 - i;

        if (wc_ed25519_import_public(exportPKey, exportPSz, &key2) != 0)
            return -1057 - i;

        if (wc_ed25519_export_private_only(&key, exportSKey, &exportSSz) != 0)
            return -1063 - i;

        if (wc_ed25519_import_private_key(exportSKey, exportSSz,
                                          exportPKey, exportPSz, &key2) != 0)
            return -1069 - i;

        /* clear "out" buffer and test sign with imported keys */
        outlen = sizeof(out);
        XMEMSET(out, 0, sizeof(out));
        if (wc_ed25519_sign_msg(msgs[i], msgSz[i], out, &outlen, &key2) != 0)
            return -1075 - i;

        if (wc_ed25519_verify_msg(out, outlen, msgs[i], msgSz[i], &verify,
                                  &key2) != 0 || verify != 1)
            return -1081 - i;

        if (XMEMCMP(out, sigs[i], 64))
            return -1087 - i;
    }

    /* clean up keys when done */
    wc_ed25519_free(&key);
    wc_ed25519_free(&key2);

#if defined(HAVE_HASHDRBG) || defined(NO_RC4)
    wc_FreeRng(&rng);
#endif

    /* hush warrnings of unused keySz and sigSz */
    (void)keySz;
    (void)sigSz;

    return 0;
}
#endif /* HAVE_ED25519 */


int wolfcrypt_test(void* args)
{
    int ret = 0;

    ((func_args*)args)->return_code = -1; /* error state */

#ifdef HAVE_FIPS
    wolfCrypt_SetCb_fips(myFipsCb);
#endif


    #ifdef HAVE_HKDF
        if ( (ret = hkdf_test()) != 0)
            return err_sys("HMAC-KDF    test failed!\n");
        else
            printf( "HMAC-KDF    test passed!\n");
    #endif

#endif


#ifdef OPENSSL_EXTRA
    if ( (ret = openssl_test()) != 0)
        return err_sys("OPENSSL  test failed!\n");
    else
        printf( "OPENSSL  test passed!\n");
#endif

#ifdef HAVE_ECC
    if ( (ret = ecc_test()) != 0)
        return err_sys("ECC      test failed!\n");
    else
        printf( "ECC      test passed!\n");
    #ifdef HAVE_ECC_ENCRYPT
        if ( (ret = ecc_encrypt_test()) != 0)
            return err_sys("ECC Enc  test failed!\n");
        else
            printf( "ECC Enc  test passed!\n");
    #endif
#endif

#ifdef HAVE_CURVE25519
    if ( (ret = curve25519_test()) != 0)
        return err_sys("CURVE25519 test failed!\n");
    else
        printf( "CURVE25519 test passed!\n");
#endif

#ifdef HAVE_ED25519
    if ( (ret = ed25519_test()) != 0)
        return err_sys("ED25519  test failed!\n");
    else
        printf( "ED25519  test passed!\n");
#endif


    ((func_args*)args)->return_code = ret;

    return ret;
}

int main(int argc, char** argv)
{
	func_args args;


#ifdef HAVE_CAVIUM
	int ret = OpenNitroxDevice(CAVIUM_DIRECT, CAVIUM_DEV_ID);
	if (ret != 0) {
		err_sys("Cavium OpenNitroxDevice failed");
		return -1236;
	}
#endif /* HAVE_CAVIUM */

	args.argc = argc;
	args.argv = argv;

	wolfcrypt_test(&args);

#ifdef HAVE_CAVIUM
	CspShutdown(CAVIUM_DEV_ID);
#endif

	return args.return_code;
}


